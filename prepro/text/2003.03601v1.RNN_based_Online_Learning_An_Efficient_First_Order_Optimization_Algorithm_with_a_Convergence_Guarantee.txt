RNN-based Online Learning: An Efficient
First-Order Optimization Algorithm with a
Convergence Guarantee

arXiv:2003.03601v1 [cs.LG] 7 Mar 2020

N. Mert Vural, Selim F. Yilmaz, Fatih Ilhan and Suleyman S. Kozat, Senior Member, IEEE

Abstract—We investigate online nonlinear regression with
continually running recurrent neural network networks (RNNs),
i.e., RNN-based online learning. For RNN-based online learning,
we introduce an efficient first-order training algorithm that
theoretically guarantees to converge to the optimum network
parameters. Our algorithm is truly online such that it does not
make any assumption on the learning environment to guarantee convergence. Through numerical simulations, we verify
our theoretical results and illustrate significant performance
improvements achieved by our algorithm with respect to the
state-of-the-art RNN training methods.
Index Terms—Online learning, neural network training, recurrent neural networks, sequential learning, regression, online
gradient descent.

I. INTRODUCTION
Prediction of individual sequences is one of the main
subjects of interest in the contemporary online learning literature [1]. In this problem, we sequentially receive a data
sequence related to a desired signal to predict the signal’s next
value [2]. This problem is also known as online regression
and extensively studied in the neural network [3], [4], signal
processing [5], [6], and machine learning literatures [1], [2].
In these studies, nonlinear approaches are generally employed
since linear modeling is inadequate for a wide range of
applications due to constraint of linearity [3], [6].
For online regression, there exists a wide range of nonlinear approaches in the fields of machine learning and signal
processing [6]–[8]. However, these approaches usually suffer
from prohibitive computational requirements and may provide
poor performance due to overfitting and stability issues [5].
Adopting neural networks is another method for online nonlinear regression due to their success in approximating nonlinear
functions [3], [9]. However, neural network-based regression
algorithms are shown to be prone to such issues as overfitting
or demonstrating inadequate performance in certain applications [10], [11]. To overcome the limitations of the shallow
networks, neural networks composed of multiple layers, i.e.,
deep neural networks (DNNs), have recently been introduced.
In DNNs, each layer performs a feature extraction based on the
previous layers, which enables them to model highly nonlinear
structures [12], [13]. However, this layered structure poorly
This work is supported in part by TUBITAK Contract No. 117E153.
N. M. Vural, S. F. Yilmaz, F. Ilhan and S. S. Kozat are with the Department of Electrical and Electronics Engineering, Bilkent University, Ankara
06800, Turkey, e-mail: vural@ee.bilkent.edu.tr, syilmaz@ee.bilkent.edu.tr,
filhan@ee.bilkent.edu.tr, kozat@ee.bilkent.edu.tr.

performs in capturing time dependencies of the data due to
its lack of temporal memory. Therefore, DNNs provide only
limited performance in processing temporal data and modeling
time series [14]. To remedy this issue, recurrent neural networks (RNNs) are used, as these networks have a feed-back
connection that enables them to store past information [7],
[15]. Through their many variants, recurrent neural networks
have seen remarkable empirical success in a broad range of
sequential learning domains [4], [16]–[18]. In this study, we
are interested in online nonlinear regression with RNN-based
networks due to their superior performance in capturing time
dependencies.
For RNNs, there exists a wide range of online training methods to learn network parameters [4], [19]–[23]. Among them,
the first-order methods are commonly preferred in practice due
to their computational efficiency [19], [22], [23]. However,
using gradient-based optimization methods for RNN-based
online learning is challenging due to the divergence problems
caused by the exploding gradient problem [24]. In addition to
this, finding an effective learning rate for first-order methods
requires time-consuming search algorithms [25], which costs a
significant amount of time and effort in practical applications.
To resolve these problems, several heuristic methods have
been proposed. For the divergence problems: Krueger et
al. [26] penalized the squared distance between the norms of
successive hidden states to keep the RNN model stable during
training. Mikolov et al. [26] and Pascanu et al. [27] showed
that gradient clipping helps to reduce exploding gradients in
practice. To overcome the learning rate-related problems: Blier
et al. [28] applied multiple learning rates with adaptive randomization, which is shown to perform close to the stochastic
gradient descent (SGD) with the optimal learning rate. As an
alternative approach, Orabona et al. [29] randomly performed
gradient descent updates with a fixed learning rate, which is
again empirically shown to be successful in neural network
training.
While these heuristics are reasonably successful in practice,
they are ad-hoc and based on empirical observations, which
may not necessarily be applicable in online settings. There
are also mathematical studies in the literature to provide
theoretical performance guarantees for RNN-based learning:
Hardt et al. [30] showed that the gradient descent algorithm
learns the globally optimum weights when the learning model
is a single input single output linear dynamical system. Oymak
et al. [31] extended this result to the contractive nonlinear
dynamical systems by assuming that the ground truth hidden

state vectors are observed. Additionally, Allen-Zhu et al. [32]
showed the Elman Network trained with SGD is capable of
minimizing the regression loss with the assumption that the
number of neurons is polynomial in the training data size.
Although these studies provide definite solutions for potential problems of the first-order methods, the conditions of
their results are restrictive for online settings. Therefore, their
results are usually inapplicable to practical online learning
scenarios. In this study, differing from the previous works, we
introduce a first-order optimization algorithm that theoretically
guarantees to learn the locally optimum parameters without
any assumption on the input/output sequences (except their
boundedness) or the system dynamics of the model. We
emphasize that our convergence guarantee is valid when our
algorithm is used with commonly used RNN models, e.g.,
Elman networks [33] and LSTMs [34].
To obtain this result, we model RNN optimization as a
sequential learning problem and assume each time step as
a separate loss function, whose argument is the network
weights (detailed in the following). By using the Lipschitz
characteristics of these loss functions, we develop an online
gradient descent algorithm that guarantees to converge to the
weights with zero derivatives. In the simulations, we verify our
theoretical results and show that our algorithm improves the
error performance of the state-of-the-art methods [19], [22],
[23] on several real-life datasets. Therefore, in this paper, we
introduce a both practical and theoretically justified algorithm
that can be used safely in RNN-based online learning settings.
Our contributions can be summarized as follows:
• To the best of our knowledge, we, as the first time in
the literature, introduce an online first-order optimization
algorithm that guarantees to learn the locally optimum
parameters when used with practical RNN models. We
note that previous studies in the literature either make
ad-hoc assumptions in their results or give a theoretical
justification for restricted settings that do not sufficiently
describe the practical scenarios.
• Our algorithm is truly online such that it does not make
any assumption on the desired data sequence to guarantee
convergence. Therefore, it can be safely used in any
practical application.
• Through simulations involving real-life datasets, we illustrate significant performance gains achieved by our
algorithm with respect to the state-of-the-art methods
[19], [22], [23].
This paper is organized as follows: In Section II, we
formally introduce the online regression problem and describe
our RNN model. In Section III, we develop a first-order optimization algorithm with a theoretical convergence guarantee.
In Section IV, we verify our results and demonstrate the
performance of our algorithm with numerical simulations. In
Section V. we conclude the paper with final remarks.
II. M ODEL AND P ROBLEM D EFINITION
All vectors are column vectors and denoted by boldface
lower case letters. Matrices are represented by boldface capital
letters. We use k·k (respectively k·k∞ ) to denote the `2

(respectively `∞ ) vector or matrix norms depending on the
argument. We use bracket notation [n] to denote the set of the
first n positive integers, i.e., [n] = {1, · · · , n}.
We study online regression, where we observe a desired
signal {dt }t≥1 and regression vectors {xt }t≥1 to sequentially
estimate dt with dˆt . For mathematical convenience in the
√
√
proofs, we assume dt ∈ [− nh , nh ], with a user-dependent
nh ∈ , and xt ∈ [−1, 1]nx . However, our derivations hold
for any bounded input/output sequence after proper shifting
and scaling. Given our estimate dˆt , which is a function
of {· · · , xt−1 , xt } and {· · · , dt−2 , dt−1 }, we suffer the loss
`(dt , dˆt ). Our aim is to optimize the network with respect to
the loss function `(·, ·). In this study, we particularly work with
the squared loss, i.e., `(dˆt , dt ) = 0.5(dt − dˆt )2 .1 However,
since our work uses a generic approach for the gradientbased non-convex optimization, it can be extended for any
continuous cost function. An extension for the cross-entropy
loss is given in Appendix C.

N

In this paper, we study online regression with continually
running RNNs [35]. For this task, we use the Elman network
model, i.e.,

ht+1 = tanh(Wht + Uxt )
dˆt = cT ht .

(1)
(2)

R

nh ×nh
Here, as the weight matrices, we have W ∈
,
U ∈ nh ×nx and c ∈ nh , with kck ≤ 1.2 Moreover,
ht ∈ [−1, 1]nh is the hidden state vector, xt ∈ [−1, 1]nx is the
√
√
input vector, dˆt ∈ [− nh , nh ] is our estimation, and tanh
applies to vectors point-wise. We note that we use the Elman
network model with tanh and linear activations in (1)-(2) due
to the wide use and simplicity of this model [36]. However,
our derivations can be extended for any differentiable neural
network architecture, given that the Lipschitz properties of the
architecture can be explicitly derived. The sketch of such an
extension for LSTMs is given in Appendix D. Additionally,
although we do not explicitly write the bias terms, they can
be included in (1)-(2) by augmenting the input vectors with a
constant dimension.

R

R

III. A LGORITHM D EVELOPMENT

In this section, we develop an online first-order algorithm
that guarantees convergence to the locally optimum weights.
We develop our algorithm in three subsections. In the first
subsection, we describe our sequential learning approach and
make definitions for the following analysis. In the second
subsection, we present some auxiliary results that will be
used in the development of the main algorithm. In the last
subsection, we introduce our algorithm and mathematically
prove its convergence guarantee.

Output Layer
ˆ
cT
t ht (θt , µt ) = dt

Initial
h
State 1

RNN pass -defined in (1)- h2
parametrized by
θt and µt

Input
Vectors

x1

RNN pass
parametrized by
θt and µt

h3

···

ht−1

RNN pass
parametrized by
θt and µt

x2

ht (θt , µt )

xt

Unfolded version of the RNN model in (1)-(2) over all the time steps up to the current time step t.
Note that all forward passes share the same parameters, i.e., θt and µt .

Fig. 1: In this figure, we visually describe ht (θt , µt ), where ht (θt , µt ) is defined as the hidden state vector obtained by running the model in (1)-(2) with
θt and µt from the initial time step up to the current time step t. In the figure, the RNN sequence is initialized with a predetermined initial state h1 , which
is independent of the network weights. Then, the same RNN forward pass (given in (1)) is repeatedly applied to the input sequence {xt }t≥1 , where all the
iterations are parametrized by θt and µt . The resulting hidden vector after t iterations is defined to be ht (θt , µt ). Here, we note that the dependence of
ht (·, ·) on t is due to the increased length of the recursion at each time step.

A. Sequential Learning Approach
We investigate the RNN-based regression problem problem
in the sequential learning framework. Here, we make no
statistical assumptions on the data in order to model chaotic,
non-stationary or even adversarial environments. Hence, we
model our problem as a game between a learner and an
adversary, where the learner is tasked with predicting the
weight matrices from some convex sets in each round t. In
the following, we use the vectorized forms of the weight
matrices, i.e., θt = vec(Wt ) and µt = vec(Ut ), for mathematical convenience. Therefore, we construct the game as
follows: At each round t, the learner declares his prediction
θt and µt ; concurrently, the adversary chooses a target value
√
√
dt ∈ [− nh , nh ], an input xt ∈ [−1, 1]nx , and a weight
vector ct , kct k ≤ 1; then, the learner observes the loss function
2
`t (θt , µt ) := 0.5 dt − cTt ht (θt , µt )
(3)
|
{z
}
dˆt

and suffers the loss `t (θt , µt ), where ht (θt , µt ) denotes the
hidden state vector obtained by running the model in (1)-(2)
with θt and µt from the initial time step up to the current
time step t (for the detailed description of ht (θt , µt ) see Fig.
1). This procedure of play is repeated across T rounds, where
T is the total number of input instances. Here, we note that
we constructed our setting for adversarial ct selections for
mathematical convenience in our proofs. However, since the
selected `t (θt , µt ) is convex with respect to ct , we will use
the online gradient descent algorithm [37] to learn the optimal
output layer weights (simultaneously with the hidden layer
weights) during the training.
Since we assume no statistical assumptions on the input/output sequences, we analyze our performance with the
notion of regret. However, we note that the standard regret
1 We scale the squared loss with 0.5 for mathematical convenience when
computing the derivatives.
2 We note that the boundedness of c will be required in our proofs. However,
our algorithm will guarantee to keep c bounded with a proper projection
onto a convex set. Here, we assume in particular kck ≤ 1 for mathematical
convenience in the proofs.

definition for the convex problems is intractable in the nonconvex settings due to the NP-hardness of the non-convex
global optimization [38], [39]. Therefore, we use the notion
of local regret recently introduced by Hazan et al. [39], which
quantifies the objective of predicting points with a small
gradient on average.
To formulate the local regret for our setting, we first define
the projected partial derivatives of `t (θ, µ) with respect to θ
and µ as follows:
h
1
∂Kθ ,ηθ `t (θ, µ)
∂`t (θ, µ) i
:=
, (4)
θ − ΠKθ θ − ηθ
∂θ
ηθ
∂θ
h
∂Kµ ,ηµ `t (θ, µ)
1
∂`t (θ, µ) i
:=
µ − ΠKµ µ − ηµ
. (5)
∂µ
ηµ
∂µ
Here, ∂K,η denotes the projected partial derivative operator
defined with some convex set K and some learning rate η, the
learning rates ηθ and ηµ are used to update θt and µt , the
operators ΠKθ[·] and ΠKµ[·] denote the orthogonal projections
onto Kθ and Kµ .
We define the time-smoothed loss at time t, parametrized
by some window size w ∈ [T ], as
Lt,w (θ, µ) :=

w−1
1 X
`t−i (θ, µ).
w i=0

(6)

Then, we define the local regret as
Rw (T ) :=

T 
X
∂Kθ ,ηθ Lt,w (θt , µt )
∂θ
t=1

2

+

∂Kµ ,ηµ Lt,w (θt , µt )
∂µ

2

.

(7)

Our aim is to derive a sublinear upper bound for Rw (T )
in order to ensure the convergence of our algorithm to the
locally optimum weights. However, before the derivations,
we first present some auxiliary results, i.e., the Lipschitz and
smoothness properties of Lt,w (θ, µ), which will be used in
the convergence proof of our algorithm.
B. Lipschitz and Smoothness Properties
In this section, we derive the Lipschitz and smoothness
properties of the time-smoothed loss function Lt,w (θ, µ). We

note that Lt,w (θ, µ) is defined as the average of the most
recent w instant loss functions (see (6)), where the loss
function `t (θ, µ) recursively depends on θ and µ due to
ht (θ, µ) (see (3) and Fig. 1). We emphasize that since we are
interested in online learning, this recursion can be infinitely
long, which might cause Lt,w (θ, µ) to have unboundedly large
derivatives. On the other hand, online algorithms naturally
require loss functions with bounded gradients to guarantee
convergence [40]. Therefore, in the following, we first analyze
the (potentially infinite) recursive dependency of Lt,w (θ, µ)
on µ and θ, where we derive sufficient conditions for its
derivatives to be bounded. Then, we use the results of this
analysis to find the explicit formulations of the Lipschitz and
smoothness constants of Lt,w (θ, µ) in terms of the model
parameters defining our RNN model in (1)-(2).
To analyse the effect of recursion, we first write the hidden
state update in (1) with the vectorized weight matrices as
ht+1 = tanh(Ht θ + Xt µ)

(8)

where Ht = I ⊗ hTt , Xt = I ⊗ xTt , and ⊗ is the Kronecker
product.
We, then, provide the following lemma, where we derive
the Lipschitz and smoothness properties of the single RNN
iteration defined in (8).
Lemma 1. Let W and U the hidden layer weight matrices
in the model (1)-(2), which satisfy kWk ≤ λ, and kUk ≤ λ
for some λ ∈ . By using the equivalent hidden state update
formula in (8), the Lipschitz and smoothness properties of the
single RNN iteration can be written as:

R

∂ tanh(Ht θ + Xt µ)
≤ λ,
∂ht
(9)

√
∂ tanh(Ht θ+Xt µ)
≤ nh ,
∂θ
(14)
√
∂ tanh(Ht θ+Xt µ)
≤ nx ,
∂µ
(15)

∂ 2 tanh(Ht θ + Xt µ)
≤ 2λ2 ,
∂h2t
(10)
2
∂ 2 tanh(Ht θ+Xt µ)
√
∂ tanh(Ht θ + Xt µ)
≤ 2nh ,
≤ 2λ nh ,
∂θ 2
∂ht ∂θ
(16)
(11)
2
2
∂
tanh(H
θ+X
µ)
t
t
√
∂ tanh(Ht θ + Xt µ)
≤ 2nx ,
≤ 2λ nx ,
∂µ2
∂ht ∂µ
(17)
(12)
2
√ √
∂ tanh(Ht θ + Xt µ)
≤ 2 nx nh .
∂θ∂µ
(13)

Proof. See Appendix A.
In the following lemma and remark, we derive the Lipschitz
properties of ht (θ, µ), and observe the effect of infinitely long
recursion on the derivatives of Lt,w (θ, µ).
Lemma 2. Let W, W0 ,U, U0 satisfy kWk, kW0 k ≤ λ, and
kUk, kU0 k ≤ λ. By using the notation in (8), let ht (θ, µ) and
ht (θ 0 , µ0 ) be the state vectors obtained at time t by running
the model in (1)-(2) with the matrices W, U, and W0 , U0
on common input sequence {x1 , x2 , · · · , xt−1 }, respectively.

If h1 (θ, µ) = h1 (θ 0 , µ0 ), then
kht (θ, µ) − ht (θ 0 , µ0 )k ≤

t
X

λi

√

nh kθ − θ 0 k +

√


nx kµ − µ0 k .

i=0

(18)
Proof. See Appendix A.
Remark 1. We note that, by (18), to ensure ht (θ, µ) has a
bounded gradient with respect to θ and µ in an infinite time
horizon, λ should be in [0, 1), i.e., λ ∈ [0, 1). In this case, the
right hand side of (18) becomes bounded, i.e.,
√
√
nh
nx
kθ − θ 0 k +
kµ − µ0 k
kht (θ, µ) − ht (θ 0 , µ0 )k ≤
1−λ
1−λ
(19)
for any t ∈ [T ].
Recall that Ltw (θ, µ) is dependent on ht (θ, µ) due to (6)
and (3). Hence, to ensure the derivatives of Ltw (θ, µ) stay
bounded, we need to constrain our parameter space as Kθ =
{vec(W) : kWk ≤ λ} and Kµ = {vec(U) : kUk ≤ λ} for
some λ ∈ [0, 1). We note that since Kθ and Kµ are convex
sets for any λ ∈ [0, 1), our constraint does not violate the
setting described in the previous subsection.
Now that we have found λ ∈ [0, 1) is sufficient for
Lt,w (θ, µ) to have bounded derivatives in any t ∈ [T ], in the
following theorem, we provide its Lipschitz and smoothness
constants.
Theorem 1. Let θ = vec(W) and µ = vec(U) , where W
and U satisfy kWk ≤ λ, and kUk ≤ λ for some λ ∈ [0, 1).
Then, Lt,w (θ, µ) has the following Lipschitz and smoothness
properties:
1)
2)
3)
4)
5)

∂Lt,w (θ, µ)
∂θ
∂Lt,w (θ, µ)
∂µ
2
∂ Lt,w (θ, µ)
∂θ 2
2
∂ Lt,w (θ, µ)
∂µ2
2
∂ Lt,w (θ, µ)
∂θ∂µ

2nh
.
1√
−λ
2 nh nx
where Rµ =
.
1−λ
√
4nh nh
where βθ =
.
(1 − λ)3
√
4nx nh
where βµ =
.
(1 − λ)3
√
4nh nx
where βθµ =
.
(1 − λ)3

≤ Rθ , where Rθ =

(20)

≤ Rµ ,

(21)

≤ βθ ,
≤ βµ ,
≤ βθµ ,

(22)
(23)
(24)

Proof. See Appendix B.
In the following section, we use these properties to derive
an RNN learning algorithm with a convergence guarantee.
C. Main Algorithm
Here, we present our main algorithm, namely the Windowed
Online Gradient Descent Algorithm (WOGD), shown in Algorithm 1.
In the algorithm, we take the window size w ∈ [T ] and
λ ∈ [0, 1) as the inputs. We, then, define the parameter spaces
Kθ , Kµ , and Kc in line 3. Here, we define Kθ and Kµ as given
in Remark 1 to ensure that the derivatives of the loss functions
are bounded. Furthermore, we define Kc as Kc = {c : kck ≤
1} to satisfy our assumption of kck ≤ 1.

Algorithm 1 Windowed Online Gradient Descent Algorithm
(WOGD)
1: Parameters: w ∈ [T ], λ ∈ [0, 1).
2: Initialize θ1 , µ1 , c1 and h1 .
3: Let Kθ = {vec(W) : kWk < λ}

4:
5:
6:
7:
8:

Kµ = {vec(U) : kUk ≤ λ}
Kc = {c : kck ≤ 1}
for t = 1 to T do
Predict θt , µt and ct .
Receive xt and generate dˆt .
Observe dt and the cost function `t (θt , µt ).

Updates:
h
1 ∂`t (θ, µ) i
ct+1 = ΠKc ct − √
∂ct
t
∂Kθ ,ηθ Lt,w (θt , µt )
θt+1 = θt − ηθ
∂θ
∂Kµ ,ηµ Lt,w (θt , µt )
µt+1 = µt − ηµ
.
∂µ

(25)
(26)
(27)

9: end for

In the learning part, we first predict the hidden layer weight
matrices in their vectorized forms, i.e., θt and µt , and the
output layer weights, i.e., ct (see line 5). Then, we receive the
input vector xt and generate dˆt by running the model in (1)-(2).
We next observe ground truth value dt and the loss function
`t (θt , µt ) in line 7. Having observed the label, we update the
weight matrices in line 8 (or in (25)-(27)). Here, we update
the output layer weights ct with the projected online gradient
descent algorithm [37], since `t (θt , µt ) is convex with respect
to ct . We update the hidden weights in (26)-(27) by using
their projected partial derivatives defined with (Kθ , ηθ ) and
(Kµ , ηµ ).
We note that since we constructed our setting for adversarial
ct selections, the update rule for the output layer in (25) does
not contradict with our analysis. Moreover, by using [37, Theorem 1], we can prove that this update rule converges to the best
possible output layer weights satisfying kck ≤ 1. Therefore, in
the following theorem, we provide the convergence guarantee
of WOGD specifically for the hidden layer weights.
Theorem 2. Let `t (θ, µ) and Lt,w (θ, µ) be the loss and timesmoothed loss functions defined in (3) and (6), respectively.
Moreover, let βθ and βµ be the smoothness parameters defined
in (22)-(23). Then, if WOGD is run with the parameters
0 < ηθ ≤

1
1
and 0 < ηµ ≤
,
2βθ
2βµ

(28)

√
8 nh
T
,
min{ηθ , ηµ } w

(29)

it ensures that
Rw (T ) ≤

where Rw (T ) is the local regret defined in (7). By selecting
T
a window size w such that w
= o(T ), one can bound Rw (T )
with a sublinear bound, hence, guarantee convergence of the
hidden layer weights to the locally optimum parameters.3
3 We use little-o notation, i.e., g(x) = o(f (x)), to describe an upper-bound
that cannot be tight, i.e., limx→∞ g(x)/f (x) = 0.

Proof. See Appendix B.
Theorem 2 shows that with appropriate parameter selections, WOGD is guaranteed to converge to the locally optimum hidden layer weights without any assumption on the
input/output sequences and output layer weights ct . Additionally, recall that by [37, Theorem 1], the output layer weights
also converge to the best weights in hindsight. Therefore,
we conclude that WOGD with the learning rates in (28)
guarantees to learn the locally optimum RNN parameters for
any bounded input/output sequences.
Now that we have proved the convergence guarantee of
WOGD, in the following remark, we investigate the computational requirement of WOGD and comment on the window
size selection for the algorithm.
Remark 2. We note that the most expensive operation of
WOGD is the computation of the projected partial derivatives
in (26)-(27), which requires the computation of the partial
derivatives of Lt,w (θ, µ) with respect to θ and µ, and their
corresponding projections onto Kθ and Kµ . To compute the
partial derivatives, we use the Truncated Backpropagation
Through Time algorithm [41], which has O hnh (nh + nx )
computational complexity with a truncation length h. Since
WOGD uses the partial derivatives of the last w losses, we
can approximate these partial derivatives with a single backpropagation by using a truncation length h =w + n for some
n ∈ , which results in O wnh (nh + nx ) computational
requirement for computing the partial derivatives. In addition, the projection step can be performed by computing the
singular value decomposition (SVD) of the weight matrices
W and U, and clipping their singular values with λ2 . Here,

since performing SVD requires O min{nh , nx }nh (nh + nx ) ,
the computational requirement
of WOGD becomes O (w +

min{nh , nx })nh (nh + nx ) per time step.
We highlight that WOGD introduces a tradeoff between
the convergence speed and computational complexity. For
example, one can choose a large window size w to ensure
fast convergence (see (29)) by increasing the computational
requirement of WOGD, or vice versa. However,√ as we will
show in the following section, selecting w = d T e usually
provides the best trade-off between performance and efficiency.

N

In the next remark, we discuss the effect of choosing higher
learning rates than the theoretically guaranteed ones given in
Theorem 2.
Remark 3. We note that WOGD is constructed by assuming
the worst-case Lipschitz constants derived in Theorem 1. On
the other hand, our experiments suggest that in practice, the
landscape of the objective function is generally nicer what
is predicted by our theoretical development. For example, in
the simulations, it is observed that the smoothness parameters
of the error surface, i.e., βθ and βµ , is usually 500 to 1000
times smaller than the values given in (22)-(23). Therefore, it is
practically possible to obtain vanishing gradient with WOGD
by using much higher learning rates than theoretically guaranteed learning rates in (28). As the regret bound of WOGD
is inversely proportional with the learning rates (see (29)), in

the following, we use WOGD with the higher learning rates
than suggested in Theorem 2 to obtain faster convergence.
IV. S IMULATIONS
In this section, we verify our theoretical analysis and illustrate the performance of our algorithm on different real-life
datasets. In particular, we consider the regression performance
for elevators [42], and pumadyn [43] datasets. To demonstrate
the performance improvements of our algorithm, we compare
it with the three widely used first-order optimization algorithms: Adam [19], RmsProp [22] and SGD [23].
For all the simulations, we randomly draw the initial RNN
weights from a Gaussian distribution with zero mean and
standard deviation of 0.1, and set the initial values of all
internal state variables to 0. For a fair comparison, in each
experiment, we choose the hyper-parameters such that all the
compared algorithms reach their maximum performance in
that setup. We run each experiment 10 times and provide the
mean performances.
A. Elevators Dataset
In the first simulation, we consider the regression performance on the elevators dataset [42], which includes 10000
input/output pairs obtained from a procedure that is related to
controlling an F16 aircraft, i.e., T = 10000. Here, our aim is
to predict the scalar output that expresses the actions of the
F16-aircraft. For this, we use 18-dimensional input vectors of
the dataset with an additional bias dimension, i.e., nx = 19. To
get small loss values with relatively lower run-time, we use 16dimensional state vectors in RNNs, i.e., nh = 16. In WOGD,
we use ηθ = 0.006, ηµ = 0.0075, λ = 0.9 , w = 100. In
Adam, RmsProp and SGD, we respectively choose the learning
rates as 0.002, 0.004 and 0.004. We note that we do not use
momentum in SGD.
In Fig. 2a, we demonstrate the temporal loss of the compared algorithms for the elevators dataset. Here, we observe
that despite the differences in the performances at the beginning, RmsProp, Adam and SGD converge to the similar loss
values. We also observe that since WOGD obtains small loss
values much faster than the other algorithms, it can track the
desired data sequence with lower error values throughout the
simulations.
To observe how window size affects the performance, we
run WOGD with six different window sizes, namely w ∈
{10, 30, 50, 100, 300, 500}, and plot their resulting temporal
performance in Fig. 2b. Here, we see that as consistent with
our regret bound in Theorem 2, the final loss values obtained
by the algorithms are inversely proportional to their window
sizes. Moreover, we observe that in the initial part of the
experiment, the algorithms with larger window sizes tend to
suffer larger losses, as averaging gradients in a large window
prevents them to overfit to the small amount of data observed
in the earlier stage. From the figure, we can observe that the
WOGD with w = 100 provides comparable performance with
the others at both initial and final parts of the experiments.
As the computational requirement of our algorithm is linear

in w (see Remark bla), selecting w = 100 provides a highly
preferable trade-off for practical purposes.
In Figs. 2c and 2d, we compare the empirical smoothness
parameters of the smoothed loss functions with the theoretical
upper bounds derived in Theorem 1. To observe the behaviour
of the empirical smoothness parameters without calculating the
exact Hessian matrix, we use the empirical Lipschitz constants,
i.e.,
emp
βθ,t

emp
βµ,t

=

=

∂Lt,w (θt+1 ,µt+1 )
∂θ

−

∂Lt,w (θt ,µt )
∂θ

(30)

kθt+1 − θt k
∂Lt,w (θt+1 ,µt+1 )
∂µ

−

∂Lt,w (θt ,µt )
∂µ

kµt+1 − µt k

.

(31)

emp
emp
In the figures, we observe that βθ,t
and βµ,t
are practically much lower than the theoretical upper bounds, where
the theoretical values are given in the titles of the plots.
We note that the difference between the theoretical upperbounds and empirical smoothness parameters are expected,
since we derived the worst-case upper bounds by considering
the saturation region of RNNs, which is rarely encountered in
practice due to variations in real-world datasets. Furthermore,
in Figs. 2b and 2c, we see that the learning rates we used
satisfy the requirement of Theorem 2 – stated in (28).
To verify our theoretical analysis in Theorem 2, we plot
the normalized regret of WOGD, i.e., Rw (t)/t for t ∈ [T ],
and the regret bound in (29) (scaled with 0.15) in Fig. 2d.
Here, we see that as consistent with our theoretical derivation,
the normalized regret vanishes. Moreover, it is bounded by
the regret bound scaled with 0.15. We believe that the gap
between the normalized regret and actual regret bound is due
to our adversarial model for the output layer weights, which is
mainly used for mathematical convenience. Since we update
the output layer weights simultaneously with the hidden layer
weights, deriving a tighter regret bound requires a cooperative
learning model for neural network optimization, which, to the
best of our knowledge, has not been studied in the literature.
The construction of such model and its analysis is left as an
open problem for the future studies.

B. Pumaydn Dataset
In our second simulation, we consider the pumaydn dataset
[43], which includes 8000 input/output pairs obtained from
the simulation of Unimation Puma 560 robotic arm, i.e., T =
8000. Here, our aim is to estimate the angular acceleration
of the arm by using the angular position and angular velocity
of the links. For this simulation, we use 8-dimensional input
vectors of the dataset with an additional bias dimension, i.e.,
nx = 9, and 16-dimensional state vectors in RNN, i.e., nh =
16. In WOGD, we use ηθ = 0.04, ηµ = 0.08, λ = 0.9,
w = 90. In Adam, RmsProp, and SGD, we choose the learning
rates as 0.004, 0.008, and 0.01, respectively. As in the previous
experiment, we do not use momentum in SGD.
In Fig. 3a, we demonstrate the temporal loss of the compared algorithms for the pumaydn dataset. Here, we observe
that while all algorithms provide comparable performances,
WOGD enjoys a smaller error value at the end of the

(a)

(b)

(c)

(d)

Fig. 2: (a) Sequential prediction performances of the algorithms for the elevators dataset (b)-(c) Comparison between the empirical smothness parameteres
of Lt,w (θ, µ) and their theoretical upper bounds given in (22) and (23) (d) Comparison between the normalized regret bound of WOGD, i.e., Rw (t)/t for
t ∈ [T ], and its theoretical upper bound given in (29).

simulation. In Figs. 3b and 3c, we compare the empirical
smoothness parameters (as defined in (30)-(31)) and their
theoretical upper-bound derived in Theorem 1. As in the
previous experiment, we observe that the empirical smoothemp
emp
ness parameters, namely βθ,t
and βµ,t
, are considerably
smaller than the theoretical upper bounds and our learning
rate selection satisfies the requirement in (28). In Fig. 3d,
we plot the normalized regret of WOGD, i.e., Rw (t)/t for
t ∈ [T ], and the regret bound in (29) scaled with 0.01.
As in the previous experiment, here also, we see that the
normalized regret vanishes and the regret bound scaled with
0.01 bounds the normalized regret by above, which is parallel
with our derivations in Theorem 2. Since our algorithm enjoys
this guarantee by providing comparable performance with the
state-of-the-art methods, it can be a theoretically grounded
alternative of the widely used heuristics [19], [22], [23] in
RNN-based online learning settings.
V. C ONCLUSION
We studied online nonlinear regression with continually
running RNNs, i.e., RNN-based online learning. For this problem, we introduced a first-order gradient-based optimization
algorithm that provides convergence guarantee to the locally
optimum parameters. We emphasize that unlike previous theoretical results, which holds in restricted settings [30], [31], our

algorithm is generic such that it guarantees convergence with
any smooth RNN architecture, e.g., the Elman networks [33]
or LSTMs [34], without any assumption on the input/output
sequences.
To achieve this result, we model the RNN-based online
regression problem as a sequential learning problem, where we
assumed each time step as a separate loss function assigned by
an adversary. We characterize the Lipschitz properties of these
loss functions with respect to the network weights and derived
sufficient conditions for our model to have bounded derivatives. Then, by using these results, we introduce an online
gradient descent algorithm that is guaranteed to converge to the
locally optimum parameters. In the simulations, we verify our
theoretical analysis. Here, we also demonstrate that our algorithm achieves considerable performance improvements with
respect to the state-of-the-art gradient descent methods [19],
[22], [23].
A PPENDIX A
For the following, we denote the derivative of tanh as
tanh0 , where tanh0 (x) = 1 − tanh(x)2 . Due to the space
restrictions, we denote the elementary row scaling operation
with , i.e., x W = diag(x)W, where x ∈ n , W ∈ n×m
and diag(x) ∈ n×n is the elementary scaling matrix whose

R

R

R

(a)

(b)

(c)

(d)

Fig. 3: (a) Sequential prediction performances of the algorithms for the pumaydn dataset (b)-(c) Comparison between the empirical smothness parameteres
of Lt,w (θ, µ) and their theoretical upper bounds given in (22) and (23) (d) Comparison between the normalized regret bound of WOGD, i.e., Rw (t)/t for
t ∈ [T ], and its theoretical upper bound given in (29).

diagonal elements are the components of x. Before the proofs,
we give three inequalities that will be used frequently in the
following:

R

Lemma 3. For any x, y ∈ n , W ∈
the following statements hold:
1) kx

Rn×m, where n, m ∈ N,

Wk ≤ kxk∞ kWk

(32)

2) ktanh0 (x) − tanh0 (y)k∞ ≤ 2kx − yk

(33)

3) kI ⊗ xT k = kxk.

(34)

1) Proof of (9): We note that (1) and (8) are equivalent. By
using (32) and tanh0 (x) ≤ 1 on (1), we write

∂ tanh(Wht + Uxt )
= ktanh0 (Wht + Uxt ) Wk
∂ ht
≤ ktanh0 (Wht + Uxt )k∞ kWk ≤ λ.

Proof. 1) Since x W = diag(x)W, we have kx Wk ≤
kdiag(x)kkWk, where we use the Cauchy-Schwarz inequality for bounding. Since by definition kdiag(x)k =
kxk∞ , kx Wk ≤ kdiag(x)kkWk = kxk∞ kWk.
2) Recall that tanh0 (x) = 1 − tanh(x)2 . Since tanh(x) ∈
[−1, 1], tanh is 1-Lipschitz 2-smooth. Then, by using
kxk∞ ≤ kxk for any x ∈ n , we have ktanh0 (x) −
tanh0 (y)k∞ ≤ ktanh0 (x) − tanh0 (y)k. Since tanh is 2smooth, we have ktanh0 (x) − tanh0 (y)k ≤ 2kx − yk.
3) See [44, Theorem 8].

2) Proof of (10): By using (32) and (33), we write

Proof of Lemma 1. In the following, we prove each statement
separately:

3) Proof of (11): We note that since tanh is twice differentiable, the order of partial derivatives is not important. Then,

R

∂ tanh(Wht + Uxt ) ∂ tanh(W0 ht + Uxt )
−
∂ ht
∂ ht
0
= ktanh (Wht + Uxt ) W − tanh0 (Wh0t + Uxt )
0

0

≤ ktanh (Wht + Uxt ) − tanh
≤ 2kWkkht −

0
ht kkWk

(Wh0t

Wk

+ Uxt )k∞ kWk

≤ 2λ kht − h0t k.
2

by using (32), (33), (34), and kht k ≤

√

ht (θ 0 , µ) share the same µ, in the following (between (40)(44)), we abbreviate them as ht (θ) and ht (θ 0 ):

nh , we write

∂ tanh(Ht θ + Xt µ) ∂ tanh(H0t θ + Xt µ)
−
∂θ
∂θ
0
= ktanh (Ht θ + Xt µ) Ht −tanh0 (H0t θ + Xt µ)

0

Ht k

(35)
0
0
0
≤ ktanh (Ht θ + Xt µ) − tanh (Ht θ + Xt µ)k∞ kHt k
0

≤
≤

(H0t θ

+ktanh
+ Xt µ)k∞ kHt − H0t k
(36)
0
ktanh (Wht + Uxt ) − tanh0 (Wh0t + Uxt )k∞ kHt k
+kht − h0t k
(37)

√
√
0
0
2kWk nh +1 kht − ht k ≤ (2λ nh +1)kht − ht k,

where we add ± tanh0 (H0t θ + Xt µ) Ht inside of the norm
in (35), and use the triangle inequality for (36). Here, we
omit +1 term for mathematical convenience in the following
derivations.
4) Proof of (12): This can be obtained by repeating the steps
in the proof of (11) for µ and ht .
√
5) Proof of (13): By using (32), (33), (34), kht k ≤ nh and
√
kxt k ≤ nx , we write
∂ tanh(Ht θ + Xt µ) ∂ tanh(Ht θ + Xt µ0 )
−
∂θ
∂θ
0
= ktanh (Ht θ + Xt µ) Ht − tanh0 (Ht θ + Xt µ0 )
0

0

Ht k

kht (θ) − ht (θ 0 )k =

(40)
0

0

= ktanh(Wht−1 (θ) + Uxt ) − tanh(W ht−1 (θ ) + Uxt )k (41)
≤ ktanh(Wht−1 (θ) + Uxt ) − tanh(Wht−1 (θ 0 ) + Uxt )k
+ktanh(Wht−1 (θ 0 ) + Uxt ) − tanh(W0 ht−1 (θ 0 ) + Uxt )k
(42)
√
0
0
(43)
≤ λkht−1 (θ) − ht−1 (θ )k + nh kθ − θ k
t−2 

X
√
≤
λi nh kθ − θ 0 k
(44)
i=0

(45)
Here, to obtain (42), we add ± tanh(Wht−1 (θ 0 )+Uxt ) inside
of the norm in (41), and use the triangle inequality. Then, we
use (9) and (14) to get (43). Until we reach (44), we repeatedly
apply the same bounding technique to bound the norm of the
differences between the state vectors.
Now, we bound the second term in (39). Since ht (θ 0 , µ)
and ht (θ 0 , µ0 ) share the same µ0 , in the following (between
(46)-(50)), we abbreviate them as ht (µ) and ht (µ0 ):

0

≤ ktanh (Ht θ + Xt µ) − tanh (Ht θ + Xt µ )k∞ kHt k
√ √
≤ 2kXt kkµ − µ0 kkHt k ≤ 2 nh nx kµ − µ0 k.
6) Proof of (14): By using (32), tanh0 (x) ≤ 1, and kht k ≤
√
nh ,
∂ tanh(Ht θ + Xt µ)
= ktanh0 (Ht θ + Xt µ) Ht k
∂θ
√
≤ ktanh0 (Ht θ + Xt µ)k∞ kHt k ≤ nh .
7) Proof of (15): This can be obtained by repeating the steps
in the proof of (14) for µ.
√
8) Proof of (16): By using (32), (33), (34), and kht k ≤ nh ,
we write
∂ tanh(Ht θ + Xt µ) ∂ tanh(Ht θ 0 + Xt µ)
−
∂θ
∂θ
0
= ktanh (Ht θ + Xt µ) Ht − tanh0 (Ht θ 0 + Xt µ) Ht k
≤ ktanh0 (Ht θ + Xt µ) − tanh0 (Ht θ 0 + Xt µ)k∞ kHt k
≤ 2kHt kkθ − θ 0 kkHt k ≤ 2nh kθ − θ 0 k.

kht (µ) − ht (µ0 )k =

(46)

0

0

0

0

= ktanh(W ht−1 (µ)+ Uxt )−tanh(W ht−1 (µ )+ U xt )k (47)
≤ ktanh(W0 ht−1 (µ)+ Uxt )−tanh(W0 ht−1 (µ0 )+ Uxt )k
+ktanh(W0 ht−1 (µ0 )+ Uxt )−tanh(W0 ht−1 (µ0 )+ U0 xt )k
(48)
√
(49)
≤ λkht−1 (µ) − ht−1 (µ0 )k + nx kµ − µ0 k
t−2 

X
√
≤
λi nx kµ − µ0 k
(50)
i=0

(51)
Here, for (48), we add ± tanh(W0 ht−1 (µ0 ) + Uxt ) and use
the triangle inequality. We, then, use (9) and (15) to get (49).
Until we reach (50), we repeatedly apply the same technique
to bound the norm of the differences between state vectors. In
the end, we use (44) and (50) to bound (39), which yields the
statement in the lemma.

9) Proof of (17): This can be obtained by repeating the steps
in the proof of (16) for µ.
A PPENDIX B
0

Proof of Lemma 2. Before the proof, let ht (θ , µ) be the state
vector obtained at time t by running the model in (1) with the
matrices W0 , U , input sequence {x1 , x2 , · · · , xt−1 }, and the
initial condition h1 (θ 0 , µ) = h1 (θ, µ) = h1 (θ 0 , µ0 ). Then,
kht (θ, µ) − ht (θ 0 , µ0 )k

(38)

≤ kht (θ, µ) − ht (θ 0 , µ)k + kht (θ 0 , µ) − ht (θ 0 , µ0 )k, (39)
where we add ±ht (θ 0 , µ) inside of the norm in (38), and
use the triangle inequality. We will bound the terms in (39)
separately. We begin with the first term. Since ht (θ, µ) and

Proof
of Theorem 1. Recall
that
Lt,w (θ, µ)
=
Pw−1
1
`
(θ,
µ).
Hence,
if
we
can
bound
the
derivative
t−i
i=0
w
of `t (θ, µ) for an arbitrary t ∈ [T ], the resulting bound
will be valid for Lt,w (θ, µ). Therefore, in the following, we
analyse the Lipschitz properties of `t (θ, µ) for an arbitrary
t ∈ [T ] and extend the result for Lt,w (θ, µ). In addition, in
√
√
the following, we note that since dt , dˆt ∈ [− nh , nh ] and
√
kct k ≤ 1, the `2 norm of −(dt − dˆt )c is bounded by 2 nh ,
√
i.e., k−(dt − dˆt )ck ≤ 2 nh .

1) We write

Then,

∂ dˆt
∂`t (θ, µ)
= −(dt − dˆt )
∂θ
∂θ
t
∂ dˆt  X ∂ ht ∂ hτ 
= −(dt − dˆt )
∂ ht τ =1 ∂ hτ ∂θ
≤ −(dt − dˆt )c
√
≤ 2 nh

(52)

t
X
∂ ht ∂ hτ
∂ hτ ∂θ
τ =1

t

∂ ht ∂ hτ
∂
hτ ∂θ
τ =1
∂ hi  ∂ hτ
∂ hi−1 ∂θ
i=τ +1

√
≤ 2 nh

τ =1

t
Y

∂ hi
∂
hi−1
i=τ +1

∂ hτ
∂θ
(53)

τ =1

≤

2nh
,
1−λ

(54)

∂ht ∂hτ
Here, to get (59) from (58), we add ± ∂h
inside the norm,
τ ∂θ
and use the triangle inequality. To get (60), we use (9) and
(14).
In the following, we will bound the terms in (60) separately.
We begin with the first term. Note that hτ = tanh(Whτ −1 +
Uxτ −1 ), and h0τ = tanh(W0 h0τ −1 + Uxτ −1 ). Then,

t

where we use (9) and (14) to get (53). By realizing that (54)
holds for an arbitrary t, the statement in the theorem can be
obtained.
2) By using similar steps in (52)-(54), we write

√ X t−τ ∂ hτ ∂ h0τ
2 nh
−
λ
∂θ
∂θ
τ =1

τ =1

√
≤ 2 nh

∂`t (θ, µ)
∂ dˆt
= −(dt − dˆt )
∂µ
∂µ
t
∂ dˆt  X ∂ ht ∂ hτ 
= −(dt − dˆt )
∂ ht τ =1 ∂ hτ ∂µ
≤ −(dt − dˆt )c

≤

t
X

(62)
 2λn

λt−τ

√
4nh nh  λ
1−λ 1−λ



h

+ 2nh kθ−θ 0 k
1−λ

+ 1 kθ−θ 0 k,

∂ tanh(Wh0

+Ux

(63)
(64)

)

τ −1
τ −1
where we add ±
, and use the triangle
∂θ
inequality, (11) and (16) for (62). We use Lemma 2 for (63).
Now, we bound the second term in (60). To bound the term,
∂h0
∂ht
we first focus on the term inside of the sum, i.e., ∂h
− ∂h0t :
τ

t
X
∂ ht ∂ hτ
∂
hτ ∂µ
τ =1

τ

t

√ √ X t−τ
≤ 2 nh nx
λ

(61)

t

√ X t−τ
√
≤ 2 nh
λ
2λ nh khτ −1 − h0τ −1 k+2nh kθ−θ 0 k

τ =1

√
2 nh nx
≤
,
1−λ

(60)

0

t

√ √ X t−τ
≤ 2 nh nh
λ

∂ ht ∂ h0t 
−
∂ hτ ∂ h0τ
(59)

t
t
X
√ X t−τ ∂ hτ ∂ h0τ
∂ ht ∂ h0t
≤ 2 nh
+2nh
.
λ
−
−
∂θ
∂θ
∂ hτ ∂ h0τ
τ =1
τ =1

t  Y
t
X
√
= 2 nh
τ =1

∂ h0τ
∂ hτ ∂ h0τ
+
−
∂θ
∂θ
∂θ

√ X ∂ ht
≤ 2 nh
∂ hτ
τ =1

t
X

t
X

∂`t (θ, µ) ∂`t (θ 0 , µ)
−
∂θ
∂θ
t
t
X
X
∂ h0t ∂ h0τ 
∂ ht ∂ hτ 
0 T
T
ˆ
ˆ
= (dt − dt )c
−(d
−
d
)
c
t
t
∂ h0τ ∂θ
∂ hτ ∂θ
τ =1
τ =1
(57)
t
√ X ∂ ht ∂ hτ
∂ h0 ∂ h0
(58)
≤ 2 nh
− 0t τ
∂ hτ ∂θ
∂ hτ ∂θ
τ =1

(55)

τ =1

(56)

where we use (9) and (15) to get (55). By realizing that (56)
holds for an arbitrary t, the statement in the theorem can be
obtained.
3) Let us use ht and h0t for the state vectors obtained by
running the model in (1) from the initial step up to current time
step t with the same initial condition, same input layer matrix
µ, common input sequence {x1 , · · · , xt−1 } but different θ and
θ 0 , respectively. Let us also say `t (θ 0 , µ) = 0.5(dt − dˆ0t )2 ,
where dˆ0t is the prediction of the second model producing h0t .

∂ ht ∂ h0t
−
∂ hτ ∂ h0τ

∂ h0t
∂ h0t−1

∂ ht
−
∂ ht−1
∂ h0t−1
∂ h0t
∂ ht−1
+
−
(65)
∂ h0t−1
∂ hτ
∂ hτ

√
≤ λt−τ −1 2λ2 kht−1 − h0t−1 k+2λ nh kθ−θ 0 k
∂ ht−1 ∂ h0t−1
+λ
−
(66)
∂ hτ
∂ hτ
 2λ2 √n

√
∂ ht−1 ∂ h0t−1
h
≤ λt−τ −1
+2λ nh kθ−θ 0 k+λ
−
1−λ
∂ hτ
∂ hτ
(67)

 2λ2 √n
√
h
≤ (t−τ )λt−τ −1
+2λ nh kθ − θ 0 k,
(68)
1−λ
≤

∂ ht−1
∂ hτ

∂h0

where we add ± ∂h0 t ∂h∂ht−1
, and use the triangle inequality for
τ
t−1
(65), utilize (10) and (11) for (66), and Lemma 2 for (67). We,
then, repeat the same manipulations in (65)-(67) to bound the

terms with partial derivatives. Then, the second term in (60)
can be bound as:

2nh

t
X

∂ ht
−
∂ hτ

τ =1

≤ 2nh

t
X

=

√

2 nh

∂ h0t
∂ h0τ

(69)

(t − τ )λt−τ −1

τ =1

 2λ2 √n
1−λ

h

√
+ 2λ nh kθ − θ 0 k


(70)

√
4nh nh  λ2
λ 
+
kθ − θ 0 k,
2
1 − λ (1 − λ)
1−λ

(71)

Pt

where we use the upper bound of the series
τ =1 (t −
τ )λt−τ −1 , i.e., 1/(1 − λ)2 , to get (71). Then, by using (64)
and (71), we can bound (60) as
∂`t (θ, µ) ∂`t (θ 0 , µ)
(72)
−
∂θ
∂θ√


2
4nh nh
2λ
λ
≤
+
+ 1 kθ−θ 0 k
2
1 − λ (1 − λ)
1−λ
(73)
√
4nh nh
=
kθ − θ 0 k.
(74)
(1 − λ)3
By realizing that (74) holds for an arbitrary t, the statement
in the theorem can be obtained.
4) This part can be obtained by adapting the steps in the
previous proof for µ, and use the Lipschitz conditions in (12),
(15), (17) and Lemma 2 accordingly.
5) We use the same notation in the proof of the 3rd statement.
Then,
∂`t (θ, µ) ∂`t (θ 0 , µ)
−
∂µ
∂µ
t
t
X
X
∂ h0t ∂ h0τ 
∂ ht ∂ hτ 
ˆt )cT
= (dt − dˆ0t )cT
−(d
−
d
t
∂ h0τ ∂µ
∂ hτ ∂µ
τ =1
τ =1
t
√ X ∂ ht ∂ hτ
∂ h0 ∂ h0
≤ 2 nh
− 0t τ
∂ hτ ∂µ
∂ hτ ∂µ
τ =1
t

√ X  ∂ ht
≤ 2 nh
∂ hτ
τ =1
t

√ X t−τ
≤ 2 nh
λ
τ =1

tanh(W0 h0τ −1 + Uxτ −1 ). Then,

(75)
(76)

t
X

λt−τ

τ =1

∂ hτ ∂ h0τ
−
∂µ ∂µ

(79)

t

√ X t−τ
√
√
≤ 2 nh
λ
2λ nx khτ −1 − h0τ −1 k+2 nx nh kθ−θ 0 k
τ =1

(80)

 2λ√n n

√
√
x h
t−τ
λ
+ 2 nx nh kθ−θ 0 k
≤ 2 nh
1−λ
√ τ =1


4nh nx
λ
≤
+ 1 kθ−θ 0 k,
1−λ 1−λ
t
X

∂ tanh(Wh0

+Ux

(81)
(82)

)

τ −1
τ −1
, and use the triangle
where we add ±
∂θ
inequality, (12) and (13) for (80). We use Lemma 2 for (81).
Now, we bound the second term in (78):

t

X ∂ ht
√
∂ h0
− 0t
2 nh nx
∂ hτ
∂ hτ
τ =1

(83)

t
 2 √n
X
√
√ 
h
t−τ −1 2λ
≤ 2 nh nx
(t − τ )λ
+ 2λ nh kθ − θ 0 k
1−λ
τ =1
(84)
√
4nh nx  λ2
λ 
=
+
kθ − θ 0 k,
(85)
1 − λ (1 − λ)2
1−λ

∂h0

∂ht
where we use (68) to bound the terms ∂h
− ∂h0t . Then, by
τ
τ
using (82) and (85), we bound (78) as follows:

∂`t (θ, µ) ∂`t (θ 0 , µ)
−
(86)
∂µ
∂µ
√

4nh nx  λ2
2λ
≤
+
+
1
kθ−θ 0 k
1 − λ (1 − λ)2 1 − λ
(87)
√
4nh nx
=
kθ − θ 0 k.
(88)
(1 − λ)3
By realizing that (88) holds for an arbitrary t, the statement
in the theorem can be obtained.

∂ hτ ∂ h0τ
∂ h0τ
−
+
∂µ ∂µ
∂µ

∂ ht ∂ h0t 
−
∂ hτ ∂ h0τ
(77)
t
0
0
X
√
∂ hτ ∂ hτ
∂ ht ∂ ht
−
− 0 .
+2 nh nx
∂µ ∂µ
∂
hτ
∂ hτ
τ =1
(78)
0

∂ht ∂hτ
Here, to get (77) from (76), we add ± ∂h
inside the norm,
τ ∂µ
and use the triangle inequality. To get (78), we use (9) and
(15).
We bound the terms in (80) separately. We begin with the
first term. Note that hτ = tanh(Whτ −1 + Uxτ −1 ), and h0τ =

Proof of Theorem 2. In the following, we use h·, ·i to denote
the inner product. Due to the space constraints, we omit the
arguments in the partial derivative terms, i.e.,
∂`t (θ, µ)
∂Lt,w
:=
,
∂θ
∂θ
∂`t (θ, µ)
∂Lt,w
:=
,
∂µ
∂µ

∂Kθ ,ηθ Lt,w
∂Kθ ,ηθ Lt,w (θt , µt )
:=
,
∂θ
∂θ
∂Kµ ,ηµ Lt,w (θt , µt )
∂Kθ ,ηθ Lt,w
:=
.
∂µ
∂µ

We start our proof by bounding the term Lt,w (θt+1 , µt+1 ) −

LT +1,w (θT +1 , µT +1 ) ≥ 0. Then, by using (95), we write

Lt,w (θt , µt ):
Lt,w (θt+1 , µt+1 ) − Lt,w (θt , µt )
E β
D ∂L
θ
t,w
2
, θt+1 − θt + kθt+1 − θt k
≤
∂θ
2
D ∂L
E β
t,w
µ
2
, µt+1 − µt +
kµt+1 − µt k
∂µ
2
+βθµ kθt+1 − θt kkµt+1 − µt k
(89)
E
D ∂L
E
D ∂L
∂
L
∂
L
t,w
t,w
K ,η
t,w
K ,η
t,w
− ηµ
= −ηθ
, θ θ
, θ θ
∂θ
∂θ
∂µ
∂µ
βθ ηθ2 ∂Kθ ,ηθ Lt,w 2 βµ ηµ2 ∂Kθ ,ηθ Lt,w 2
+
+
2
∂θ
2
∂µ
∂Kθ ,ηθ Lt,w ∂Kθ ,ηθ Lt,w
+βθµ ηθ ηµ
(90)
∂θ
∂µ
D ∂L
E
D ∂L
E
t,w ∂Kθ ,ηθ Lt,w
t,w ∂Kθ ,ηθ Lt,w
= −ηθ
− ηµ
,
,
∂θ
∂θ
∂µ
∂µ
 p
p
∂Kθ ,ηθ Lt,w
∂Kθ ,ηθ Lt,w 2
+ηµ βµ
+0.5 ηθ βθ
∂θ
∂µ
(91)
2

∂
L
Kθ ,ηθ t,w
≤ − ηθ − ηθ2 βθ
∂θ
 ∂Kθ ,ηθ Lt,w 2
2
− ηµ − ηµ β µ
,
(92)
∂µ
where we use [45, Lemma 3.4] for (89), thepupdate rules in
(26)-(27) for (90), and the fact that βθµ = βθ βµ for (91)
(see (22)-(24)). Moreover, for (92), we use [39, Lemma 3.2]
and the fact 2(a2 + b2 ) ≤ (a + b)2 for any a, b ∈ .
For the following, we define lt (θ, µ) = 0 for t ≤ 0.
We continue our proof by bounding LT +1,w (θT +1 , µT +1 ) as
follows:

R

LT +1,w (θT +1 , µT +1 )
=

=

+

T
X

Lt+1,w (θt+1 , µt+1 )−Lt,w (θt , µt )

t=0
T 
X
t=1
T 
X

(93)

ηθ − ηθ2 βθ

T
X
∂Kθ ,ηθ Lt,w
∂θ
t=1

T
X
∂Kθ ,ηθ Lt,w
∂θ
t=1

2

T
X
∂Kθ ,ηθ Lt,w
− ηµ − ηµ2 βµ
∂µ
t=1

2

≤ − ηθ −

2

√ T
≤ 4 nh .
w

A PPENDIX C
In this part, we describe how to extend our work for the
cross-entropy loss, which is denoted as RE(·||·). Since the
cross-entropy loss is mainly used for classification, we describe our extension by using the following RNN architecture:
ht+1 = tanh(Wht + Uxt )
dˆt = f (cT ht )
Et = RE(dt ||dˆt ).
Here, f is assumed to be the sigmoid or softmax function
depending on the dimension of the desired sequence. As in (1)(2), ht ∈ [−1, 1]nh is the hidden state vector, xt ∈ [−1, 1]nx
is the input vector, and dt , dˆt ∈ [0, 1] is our estimation.
Moreover, Et denotes the cross-entropy loss at time instance
t.
As in the squared loss, the cross-entropy is convex with
respect to output layer weights, i.e., c. Therefore, we can use
the projected online gradient descent – as in (25)– to ensure
the convergence of the output layer update. Moreover, since
the formula for the derivative of the cross-entropy function
with respect to c is the same with that of the squared loss,
ˆ
ˆ 2
t −dt )
t ||dt )
i.e., 0.5(d∂c
= ∂RE(d
= (dt − dˆt )c, the Lipschitz
∂c
properties derived in Theorem 1 applies to the the crossentropy loss as well. Since Theorem 2 uses only the Lipschitz
properties of the RNN architecture to prove convergence, it
can be extended for the cross-entropy with the same updateprojection steps in (26)-(27). Therefore, Algorithm 1 can be
used for the cross-entropy case without any change as well.
A PPENDIX D
In this part, we describe how to extend our work for LSTMs.
The equations of LSTM and the loss function is given as:

√
4 nh T
+
, (95)
w

where we add ±Lt,w (θt+1 , µt+1 ) to (93) to obtain (94), and
√
√
use (93) and dt , dˆt ∈ [− nh , nh ] for any t ∈ [T ], which
√
implies Lt+1,w (θt+1 , µt+1 ) − Lt,w (θt+1 , µt+1 ) ≤ 4 nh /w,
to obtain (95).
We note that since the `t (θt , µt ) is defined as the
square loss between the ground truth value and our prediction, it is non-negative for all t ∈ [T ], which implies

T
X
∂Kθ ,ηθ Lt,w
∂µ
t=1

By choosing 0 < ηθ ≤ 1/(2βθ ), 0 < ηµ ≤ 1/(2βµ ) and
dividing both sides of (96) with min{ηθ , ηµ }/2, we can obtain
the statement in the theorem.

t=0

ηθ2 βθ

+ ηµ − ηµ2 βµ

(96)


Lt,w (θt+1 , µt+1 ) − Lt,w (θt , µt )


Lt+1,w (θt+1 , µt+1 ) − Lt,w (θt+1 , µt+1 ) (94)

2

zt = tanh(W1 yt−1 + U1 xt )

(97)

it = σ(W2 yt−1 + U2 xt )

(98)

ft = σ(W3 yt−1 + U3 xt )

(99)

ct = it

zt + ft

ct−1

(100)

ot = σ(W4 yt−1 + U4 xt )

(101)

yt = ot tanh(ct )
dˆt = cT yt
Et = 0.5(dt − dˆt )2 .

(102)
(103)
(104)

R

where
denotes the element-wise multiplication, ct ∈ nh
is the state vector, xt ∈ [−1, 1]nx is the input vector, and
√
√
yt ∈ nh is the output vector, and dˆt ∈ [− nh , nh ] is our
final estimation. Furthermore, the sigmoid function σ(.) and

R

the hyperbolic tangent function tanh(.) applies point wise to
the vector elements. The weight matrices are Wi ∈ nh ×nh ,
Ui ∈ nh ×nx for i = 1, · · · , 4, and c ∈ nh , with kck ≤ 1.
As in the vanilla RNN case, the boundedness of c can be
guaranteed with a proper projection onto a convex set. Note
that although we do not explicitly write the bias terms, they
can be included in (97)-(103) by augmenting the input vector
with a constant dimension.
Similar to the vanilla RNN case, the loss function Et is
convex with respect to the output weights c. Therefore, we can
use the projected gradient descent to ensure the convergence
of the output layer update. For the hidden layer weights, note
that we define the projected gradients as in (4)-(5) and the
regret as as in (7) to ensure to find a stationary point for the
gradient-descent updates. Then, by using the same intuition,
we can extend the projected gradient definition for LSTM as
h
∂`t (θi , µi ) i
1
∂Kθ ,ηθ `t (θi , µi )
:=
θi − ΠKθ θi − ηθ
,
∂θi
ηθ
∂θi
h
∂Kµ ,ηµ `t (θi , µi )
∂`t (θi , µi ) i
1
:=
µi − ΠKµ µi − ηµ
∂µi
ηµ
∂µi

R

R

R

and the regret definition as
Rw (T ) :=

T X
4 
X
∂Kθ ,ηθ Lt,w (θi,t , µi,t )
∂θi
t=1 i=1

2

+

∂Kµ ,ηµ Lt,w (θi,t , µi,t )
∂µi

2

,

(105)
where θi,t and µi,t are the vectorized forms of the weight
matrices Wi,t and Ui,t at time t, i.e., θi,t = vec(Wi,t ) and
µi,t = vec(Ui,t ).
We note that the convergence analysis for our algorithm
requires the Lipschitz properties of the architecture of interest.
To this end, we can use the Lipschitz properties of LSTMs
derived in [46, Proposition 2]. Then, we can use these results
in Theorem 2 to upper-bound the regret defined in (105).
Accordingly, Algorithm 1 can be extended by for the LSTM
optimization.
REFERENCES
[1] N. Cesa-Bianchi and G. Lugosi, Prediction, Learning, and Games. New
York, NY, USA: Cambridge University Press, 2006.
[2] V. G. Vovk, “Aggregating strategies,” in Proceedings of the Third Annual
Workshop on Computational Learning Theory, ser. COLT ’90. San
Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1990, pp. 371–
386.
[3] D. F. Specht, “A general regression neural network,” IEEE Transactions
on Neural Networks, vol. 2, no. 6, pp. 568–576, Nov 1991.
[4] T. Ergen and S. S. Kozat, “Efficient online learning algorithms based
on lstm neural networks,” IEEE Transactions on Neural Networks and
Learning Systems, vol. 29, no. 8, pp. 3772–3783, Aug 2018.
[5] A. C. Singer, G. W. Wornell, and A. V. Oppenheim, “Nonlinear
autoregressive modeling and estimation in the presence of noise,” Digital
Signal Processing, vol. 4, no. 4, pp. 207 – 221, 1994. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S1051200484710219
[6] Y. Engel, S. Mannor, and R. Meir, “The kernel recursive least-squares
algorithm,” IEEE Transactions on Signal Processing, vol. 52, no. 8, pp.
2275–2285, Aug 2004.
[7] S. Haykin, Neural Networks: A Comprehensive Foundation, 2nd ed.
Upper Saddle River, NJ, USA: Prentice Hall PTR, 1998.
[8] Tsungnan Lin, B. G. Horne, P. Tino, and C. L. Giles, “Learning longterm dependencies in narx recurrent neural networks,” IEEE Transactions on Neural Networks, vol. 7, no. 6, pp. 1329–1338, Nov 1996.
[9] J. Y. Goulermas, P. Liatsis, X. Zeng, and P. Cook, “Density-driven generalized regression neural networks (dd-grnn) for function approximation,”
IEEE Transactions on Neural Networks, vol. 18, no. 6, pp. 1683–1696,
Nov 2007.

[10] N. D. Vanli, M. O. Sayin, I. Delibalta, and S. S. Kozat, “Sequential
nonlinear learning for distributed multiagent systems via extreme learning machines,” IEEE Transactions on Neural Networks and Learning
Systems, vol. 28, no. 3, pp. 546–558, March 2017.
[11] S. Lawrence and C. L. Giles, “Overfitting and neural networks: conjugate gradient and backpropagation,” in Proceedings of the IEEEINNS-ENNS International Joint Conference on Neural Networks. IJCNN
2000. Neural Computing: New Challenges and Perspectives for the New
Millennium, vol. 1, July 2000, pp. 114–119 vol.1.
[12] I. Arel, D. C. Rose, and T. P. Karnowski, “Deep machine learning - a
new frontier in artificial intelligence research [research frontier],” IEEE
Computational Intelligence Magazine, vol. 5, no. 4, pp. 13–18, Nov
2010.
[13] L. Shao, D. Wu, and X. Li, “Learning deep and wide: A spectral method
for learning deep networks,” IEEE Transactions on Neural Networks and
Learning Systems, vol. 25, no. 12, pp. 2303–2308, Dec 2014.
[14] M. Hermans and B. Schrauwen, “Training and analysing deep recurrent
neural networks,” in Advances in Neural Information Processing Systems
26, C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q.
Weinberger, Eds. Curran Associates, Inc., 2013, pp. 190–198.
[15] K. S. Narendra and K. Parthasarathy, “Identification and control of
dynamical systems using neural networks,” IEEE Transactions on Neural
Networks, vol. 1, no. 1, pp. 4–27, March 1990.
[16] P. Liu, X. Qiu, and X. Huang, “Recurrent neural network for text
classification with multi-task learning,” 2016.
[17] N. Laptev, J. Yosinski, L. E. Li, and S. Smyl, “Time-series extreme event
forecasting with neural networks at uber,” in International Conference
on Machine Learning, no. 34, 2017, pp. 1–5.
[18] W. D. Mulder, S. Bethard, and M.-F. Moens, “A survey on the application of recurrent neural networks to statistical language modeling,”
Computer Speech & Language, vol. 30, no. 1, pp. 61 – 98, 2015.
[19] D. P. Kingma and J. Ba, “Adam: A method for stochastic optimization,”
2014.
[20] J. Martens and I. Sutskever, “Learning recurrent neural networks with
hessian-free optimization,” in Proceedings of the 28th International
Conference on International Conference on Machine Learning, ser.
ICML’11. USA: Omnipress, 2011, pp. 1033–1040. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3104482.3104612
[21] G. V. Puskorius and L. A. Feldkamp, “Neurocontrol of nonlinear
dynamical systems with kalman filter trained recurrent networks,” IEEE
Transactions on Neural Networks, vol. 5, no. 2, pp. 279–297, March
1994.
[22] G. Hinton, “Neural networks for machine learning,” 2012.
[23] S. Ruder, “An overview of gradient descent optimization algorithms,”
2016.
[24] Y. Bengio, P. Simard, and P. Frasconi, “Learning long-term dependencies with gradient descent is difficult,” IEEE Transactions on Neural
Networks, vol. 5, no. 2, pp. 157–166, March 1994.
[25] K. Greff, R. K. Srivastava, J. Koutnı́k, B. R. Steunebrink, and
J. Schmidhuber, “LSTM: A search space odyssey,” CoRR, vol.
abs/1503.04069, 2015. [Online]. Available: http://arxiv.org/abs/1503.
04069
[26] D. Krueger and R. Memisevic, “Regularizing rnns by stabilizing activations,” 2015.
[27] R. Pascanu, T. Mikolov, and Y. Bengio, “On the difficulty of training
recurrent neural networks,” 2012.
[28] L. Blier, P. Wolinski, and Y. Ollivier, “Learning with random learning
rates,” 2018.
[29] F. Orabona and T. Tommasi, “Training deep networks without learning
rates through coin betting,” 2017.
[30] M. Hardt, T. Ma, and B. Recht, “Gradient descent learns linear dynamical systems,” 2016.
[31] S. Oymak, “Stochastic gradient descent learns state equations with
nonlinear activations,” 2018.
[32] Z. Allen-Zhu, Y. Li, and Z. Song, “On the convergence rate of training
recurrent neural networks,” CoRR, vol. abs/1810.12065, 2018. [Online].
Available: http://arxiv.org/abs/1810.12065
[33] J. L. Elman, “Finding structure in time,” COGNITIVE SCIENCE, vol. 14,
no. 2, pp. 179–211, 1990.
[34] S. Hochreiter and J. Schmidhuber, “Long short-term memory,” Neural
Comput., vol. 9, no. 8, pp. 1735–1780, Nov. 1997.
[35] R. J. Williams and D. Zipser, “A learning algorithm for continually
running fully recurrent neural networks,” Neural Comput., vol. 1, no. 2,
pp. 270–280, Jun. 1989. [Online]. Available: http://dx.doi.org/10.1162/
neco.1989.1.2.270

[36] Z. C. Lipton, J. Berkowitz, and C. Elkan, “A critical review of recurrent
neural networks for sequence learning,” 2015.
[37] M. Zinkevich, “Online convex programming and generalized infinitesimal gradient ascent,” vol. 2, 04 2003.
[38] S. Aydore, L. Dicker, and D. Foster, “A local regret in nonconvex online
learning,” 2018.
[39] E. Hazan, K. Singh, and C. Zhang, “Efficient regret minimization
in non-convex games,” CoRR, vol. abs/1708.00075, 2017. [Online].
Available: http://arxiv.org/abs/1708.00075
[40] S. Shalev-Shwartz, “Online learning and online convex optimization,”
Foundations and Trends in Machine Learning, vol. 4, no. 2, pp. 107–
194, 2012.
[41] R. J. Williams and D. Zipser, “Backpropagation,” Y. Chauvin and D. E.
Rumelhart, Eds. Hillsdale, NJ, USA: L. Erlbaum Associates Inc.,
1995, ch. Gradient-based Learning Algorithms for Recurrent Networks

[42]

[43]
[44]
[45]
[46]

and Their Computational Complexity, pp. 433–486. [Online]. Available:
http://dl.acm.org/citation.cfm?id=201784.201801
J. Alcal-Fdez, A. Fernndez, J. Luengo, J. Derrac, and S. Garca, “Keel
data-mining software tool: Data set repository, integration of algorithms
and experimental analysis framework.” Multiple-Valued Logic and Soft
Computing, vol. 17, no. 2-3, pp. 255–287, 2011.
C. E. Rasmussen, “Delve data sets,” http://www.cs.toronto.edu/∼delve/
data/datasets.html, accessed: 2019-07-21.
P. Lancaster and H. Farahat, “Norms on direct sums and tensor products,” Mathematics of Computation - Math. Comput., vol. 26, 05 1972.
S. Bubeck, “Convex optimization: Algorithms and complexity,” Found.
Trends Mach. Learn., vol. 8, no. 3-4, pp. 231–357, Nov. 2015. [Online].
Available: http://dx.doi.org/10.1561/2200000050
J. Miller and M. Hardt, “Stable recurrent models.” in ICLR (Poster).
OpenReview.net, 2019.

